#include "prime.h"

using namespace std;

// Returns whether `n` is prime. Determined by trial division by integers.
bool is_prime(const ull n) {
  if (n <= 3) {
    return n > 1;
  }

  if (n % 2 == 0 || n % 3 == 0) {
    return false;
  }

  const ull sqrt_n = sqrt(n);
  // Starting from 5, divides only by integers of the form 6k +- 1 (i.e. that
  // are not multiples of 2 or 3).
  for (ull i = 5; i <= sqrt_n; i += 6) {
    if (n % i == 0 || n % (i + 2) == 0) {
      return false;
    }
  }

  return true;
}

// Returns whether `n` is prime. Determined by trial division by `primes`.
bool is_prime(const ull n, vector<ull> const &primes) {
  if (n <= 3) {
    return n > 1;
  }

  const ull sqrt_n = sqrt(n);
  for (ull i = 0; primes[i] <= sqrt_n; ++i) {
    if (n % primes[i] == 0) {
      return false;
    }
  }

  return true;
}

// Returns a vector of prime numbers less than or equal to `n`. Generated by the
// sieve of Eratosthenes.
vector<ull> generate_primes(const ull n) {
  if (n <= 2) {
    return n < 2 ? vector<ull>{} : vector<ull>{2};
  }

  vector<bool> compositenesses(n + 1);

  const ull sqrt_n = sqrt(n);
  for (ull i = 5; i <= sqrt_n; i += 6) {
    if (!compositenesses[i]) {
      for (ull j = i * i; j <= n; j += i) {
        compositenesses[j] = true;
      }
    }

    const ull i_plus_2 = i + 2;
    if (!compositenesses[i_plus_2]) {
      for (ull j = i_plus_2 * i_plus_2; j <= n; j += i_plus_2) {
        compositenesses[j] = true;
      }
    }
  }

  vector<ull> primes = {2, 3};

  for (ull i = 5; i <= n; i += 6) {
    if (!compositenesses[i]) {
      primes.push_back(i);
    }

    const ull i_plus_2 = i + 2;
    if (!compositenesses[i_plus_2]) {
      primes.push_back(i_plus_2);
    }
  }

  return primes;
}

// Returns a vector of prime factors of `n`. Factored by trial division by
// integers.
vector<ull> factor(ull n) {
  if (n <= 3) {
    return n == 1 ? vector<ull>{} : vector<ull>{n};
  }

  vector<ull> prime_factors;

  while (n % 2 == 0) {
    prime_factors.push_back(2);
    n /= 2;
  }

  while (n % 3 == 0) {
    prime_factors.push_back(3);
    n /= 3;
  }

  const ull sqrt_n = sqrt(n);
  // Divides by integers of the form 6k +- 1.
  for (ull i = 5; i <= sqrt_n; i += 6) {
    while (n % i == 0) {
      prime_factors.push_back(i);
      n /= i;
    }

    const ull i_plus_2 = i + 2;
    while (n % i_plus_2 == 0) {
      prime_factors.push_back(i_plus_2);
      n /= i_plus_2;
    }
  }

  if (n != 1) {
    prime_factors.push_back(n);
  }

  return prime_factors;
}
